#!/bin/bash

# Define colors
GREEN='\033[1;32m'
NC='\033[0m' # No Color
ICON="${GREEN}(::X::)${NC}"

print_logo() {
  cat <<"EOF"
    ----------------░░░░░░░-----------------
    ---.--'-'''.---░░]▄▄▄▄▄░░--`'''''-'-''''
    ---------------░░░╣▒░╠▌░░----'''''''''''
    ''---------;░░Q▄░▀╩▓╗▌╩╩Q▄▄░░----------'
    ''''''.'.-;░╠▀░░░░░░▓░░░░░░▀▒µ---'''''''
    ------'-»╔#░░▄╧--░░╚╠╩░░--@▄░╚▒░-'''''''
     ''-'---╓╝░░╙╚≤░-""░▓░░░░≤╛╚░∩╙╩░---'''
         '!░║░░----└▒░;░▓░,µ▒░----░]▌░-
         .-╣░░░░---░░│Φ░╙]▒│-----╓░"]▌-'
       ---░╣░"╠▒╚▀▀▀▀▀▒░▀░╚▀▀▀▀▀▒╚▒-]▌░-'
          .╝Q░,---.`,╗╩░φ░╚▄-''---░░░▌-
          `░║░----;@╚░':╣=-"▒╦░----]▌└'
           '-║▒-╙║░░---░▓░-"`░░φ▒-]▌└'
            '└╙░░-╙---»≤░≥----╙;]ƒ╛░'
               `╙▀╦▄Q--└░░'.╓Qƒ▀▒⌐
                 '└└└▀▀▀▀▀▀▀░└└''
EOF
}

# Display usage information
usage() {
  echo "Usage: $0 [-d|--debug] [DIRECTORY]"
  echo ""
  echo "Play random video files from a directory."
  echo ""
  echo "Options:"
  echo "  -d, --debug  Enable debug mode (show mpv command)"
  echo "               Can also be enabled via ROULETTE_DEBUG env var"
  echo "  -h, --help   Show this help message"
  echo ""
  echo "Arguments:"
  echo "  DIRECTORY    Path to search for video files (optional)"
  echo "               If not provided, will auto-detect media directory"
  echo ""
  echo "Environment Variables:"
  echo "  ROULETTE_DEBUG   Enable debug mode (any non-empty value)"
  echo "  MPV_GEOMETRY     Set mpv window geometry (e.g., '+0+0')"
  echo "  MPV_VOLUME       Set mpv volume (0-100)"
  echo ""
  echo "Examples:"
  echo "  $0                    # Auto-detect media directory"
  echo "  $0 -d ~/Downloads     # Debug mode, search in Downloads"
  echo "  $0 /Volumes/media     # Search in specific volume"
  exit 1
}

DIRECTORY_PATH=""
USER_PROVIDED_PATH=""
VIDEO_EXTENSIONS=("mp4" "avi" "mkv" "mov" "wmv" "flv" "webm" "m4v" "mpg" "mpeg" "mp4")
MPV_PATH="/usr/local/bin/mpv"
MPV_PATH_ARM="/opt/homebrew/bin/mpv"
IS_WSL=false
IS_MACOS=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h | --help)
      usage
      ;;
    -d | --debug)
      ROULETTE_DEBUG=1
      shift
      ;;
    -*)
      echo "ERROR: Unknown option: $1"
      usage
      ;;
    *)
      # Expand tilde to home directory if present
      USER_PROVIDED_PATH="${1/#\~/${HOME}}"
      if [[ ! -d "${USER_PROVIDED_PATH}" ]]; then
        echo "ERROR: Directory not found: ${USER_PROVIDED_PATH}"
        exit 1
      fi
      DIRECTORY_PATH="${USER_PROVIDED_PATH}"
      echo "Using provided directory: ${DIRECTORY_PATH}"
      shift
      ;;
  esac
done

# Detect if running in WSL
detect_wsl() {
  if grep -qEi "(Microsoft|WSL)" /proc/version &>/dev/null; then
    IS_WSL=true
    echo "WSL environment detected."
  fi
}

# Detect if running on macOS
detect_macos() {
  if [[ "${OSTYPE}" == "darwin"* ]]; then
    IS_MACOS=true
    echo "macOS environment detected."
  fi
}

# Detect and set the correct media directory path
detect_media_directory() {
  local potential_paths=()

  if [[ "${IS_MACOS}" == true ]]; then
    # macOS: Check /Volumes first
    potential_paths=(
      "/Volumes/media/archive/video"
    )
  elif [[ "${IS_WSL}" == true ]]; then
    # WSL: Prefer network mount paths
    potential_paths=(
      "/mnt/media/archive/video"
      "/media/archive/video"
      "/mnt/m/media/archive/video"
    )
  else
    # Native Linux: Check standard mount points
    potential_paths=(
      "/media/archive/video"
      "/mnt/media/archive/video"
    )
  fi

  # Find the first existing directory
  for path in "${potential_paths[@]}"; do
    if [[ -d "${path}" ]]; then
      DIRECTORY_PATH="${path}"
      echo "Found media directory: ${DIRECTORY_PATH}"
      return 0
    fi
  done

  # If nothing found, set a default and let the script handle the error later
  if [[ "${IS_MACOS}" == true ]]; then
    DIRECTORY_PATH="/Volumes/media/archive/video"
  elif [[ "${IS_WSL}" == true ]]; then
    DIRECTORY_PATH="/mnt/media/archive/video"
  else
    DIRECTORY_PATH="/media/archive/video"
  fi

  echo "WARNING: Media directory not found. Using default: ${DIRECTORY_PATH}"
  return 1
}

check_and_install_mpv() {
  # If running in WSL, use Windows mpv.exe
  if [[ "${IS_WSL}" == true ]]; then
    # Check common Windows mpv locations
    local win_mpv_paths=(
      "/mnt/c/Program Files/mpv/mpv.exe"
      "/mnt/c/Program Files (x86)/mpv/mpv.exe"
      "/mnt/c/Users/${USER}/AppData/Local/Programs/mpv.net/mpvnet.exe"
      "$(command -v mpv.exe 2>/dev/null)"
    )

    for path in "${win_mpv_paths[@]}"; do
      if [[ -f "${path}" ]]; then
        MPV_PATH="${path}"
        echo "Found Windows MPV at: ${MPV_PATH}"
        return 0
      fi
    done

    echo "ERROR: mpv.exe not found on Windows side."
    echo "Please install mpv for Windows from https://mpv.io/installation/"
    echo "Or ensure mpv.exe is in your Windows PATH."
    exit 1
  fi

  # macOS/Linux logic
  # Check both possible locations for mpv
  if [[ -f "${MPV_PATH}" ]] || [[ -f "${MPV_PATH_ARM}" ]]; then
    echo "mpv is already installed."
    # Set the correct path based on which exists
    if [[ -f "${MPV_PATH_ARM}" ]]; then
      MPV_PATH="${MPV_PATH_ARM}"
    fi
  else
    echo "mpv is not installed. Installing using Homebrew..."

    # Check if Homebrew is installed
    if ! command -v brew &>/dev/null; then
      echo "Homebrew is not installed. Please install Homebrew first:"
      echo "Visit https://brew.sh for installation instructions"
      exit 1
    fi

    # Install mpv using Homebrew
    if brew install mpv; then
      echo "mpv installed successfully."
      # Check which path it was installed to
      if [[ -f "${MPV_PATH_ARM}" ]]; then
        MPV_PATH="${MPV_PATH_ARM}"
      fi
    else
      echo "Failed to install mpv using Homebrew. Please install it manually."
      exit 1
    fi
  fi
}

# Function to convert WSL path to Windows path
convert_path_for_mpv() {
  local path="$1"
  if [[ "${IS_WSL}" == true ]]; then
    # Convert WSL path to Windows path
    wslpath -w "${path}"
  else
    echo "${path}"
  fi
}

# Function to support env var customizations
build_mpv_args() {
  local args=()
  if [[ -n "${MPV_GEOMETRY}" ]]; then
    args+=("--geometry=${MPV_GEOMETRY}")
  fi
  if [[ -n "${MPV_VOLUME}" ]]; then
    args+=("--volume=${MPV_VOLUME}")
  fi
  echo "${args[@]}"
}

# Function to run mpv with optional debug output
run_mpv() {
  local video_path="$1"
  local mpv_args
  mpv_args=$(build_mpv_args)

  if [[ -n "${ROULETTE_DEBUG}" ]]; then
    echo -e "${GREEN}[DEBUG]${NC} ${MPV_PATH} ${mpv_args} \"${video_path}\""
  fi

  # shellcheck disable=SC2086
  "${MPV_PATH}" ${mpv_args} "${video_path}"
}

# Function to build the find command with multiple extensions
build_find_command() {
  local find_cmd="find \"${DIRECTORY_PATH}\" -type f \\( "
  local first=true

  for ext in "${VIDEO_EXTENSIONS[@]}"; do
    if [[ "${first}" == true ]]; then
      find_cmd+="-iname \"*.${ext}\""
      first=false
    else
      find_cmd+=" -o -iname \"*.${ext}\""
    fi
  done

  find_cmd+=" \\)"
  echo "${find_cmd}"
}

# Function to open a random video
open_random_video() {
  # Check if directory exists
  if [[ ! -d "${DIRECTORY_PATH}" ]]; then
    echo "Directory not found: ${DIRECTORY_PATH}"
    echo "Please update the DIRECTORY_PATH variable in the script."
    return 1
  fi

  # Build and execute the find command
  local find_cmd
  find_cmd=$(build_find_command)

  # Get all video files in the directory (including subdirectories)
  # Using mapfile (or readarray) to handle filenames with spaces
  # mapfile -t videos < <(eval "${find_cmd}")
  # Using a while loop to handle filenames with spaces (compatible with bash 3.2)
  videos=()
  # shellcheck disable=SC2312
  while IFS= read -r -d '' file; do
    videos+=("${file}")
  done < <(eval "${find_cmd} -print0")

  # Check if there are any video files
  if [[ ${#videos[@]} -eq 0 ]]; then
    echo "No video files found in the directory: ${DIRECTORY_PATH}"
    return 1
  fi

  echo "Found ${#videos[@]} video files."

  # Pick a random video file
  local random_index=$((RANDOM % ${#videos[@]}))
  random_video="${videos[${random_index}]}" # Make this global for deletion option

  # Output the path of the video being played
  echo -e "${ICON} Playing: ${random_video}"

  # Open the randomly selected video file using mpv
  local video_path
  video_path=$(convert_path_for_mpv "${random_video}")
  run_mpv "${video_path}"
}

# Main script
echo -e "${GREEN}"
print_logo
echo "   r o u l e t t e"
echo "   Version 1.0"
echo ""
echo -e "${NC}"

# Detect environment
detect_macos
detect_wsl

# Detect media directory only if user didn't provide one
if [[ -z "${USER_PROVIDED_PATH}" ]]; then
  detect_media_directory
fi

# Check and install MPV
check_and_install_mpv

# Loop to keep the script active
while true; do
  # Call the function to open a random video
  if open_random_video; then
    while true; do
      echo ""
      echo -n "[q]uit, [d]elete, [i]nfo, [r]eplay, [N]ext: "
      read -n 1 -r user_input
      echo # Add newline after single character input

      case "${user_input}" in
        "q" | "Q")
          echo "Goodbye!"
          exit 0
          ;;
        "r" | "R")
          echo "Replaying video: ${random_video}"
          video_path=$(convert_path_for_mpv "${random_video}")
          run_mpv "${video_path}"
          continue
          ;;
        "i" | "I")
          mediainfo "${random_video}"
          # After info, offer replay option
          while true; do
            echo -n "[r]eplay, [b]ack: "
            read -n 1 -r replay_input
            echo
            case "${replay_input}" in
              "r" | "R")
                video_path=$(convert_path_for_mpv "${random_video}")
                run_mpv "${video_path}"
                ;;
              "b" | "B" | "q" | "Q" | $'\n' | "")
                # Back to main prompt
                break
                ;;
              *)
                echo "Invalid option '${replay_input}'. Try again..."
                ;;
            esac
          done
          continue
          ;;
        "d" | "D")
          echo ""
          echo "WARNING: This will permanently delete the file:"
          echo "${random_video}"
          echo ""
          echo -n "Delete this file? [y/Enter=yes, n=no, q=quit]: "
          read -n 1 -r confirmation
          echo
          case "${confirmation}" in
            "y" | "Y" | $'\n' | "")
              if rm "${random_video}" 2>/dev/null; then
                echo "File deleted successfully."
              else
                echo "Failed to delete file. Check permissions."
              fi
              break
              ;;
            "q" | "Q")
              echo "Goodbye!"
              exit 0
              ;;
            "n" | "N" | *)
              echo "File deletion cancelled."
              continue
              ;;
          esac
          ;;
        "n" | "N" | " " | "")
          # Next video - break to outer loop
          break
          ;;
        *)
          echo "Invalid option '${user_input}'. Try again..."
          continue
          ;;
      esac
    done
  else
    # If there was an error, ask if they want to retry
    echo ""
    echo -n "[r]etry, [q]uit: "
    read -n 1 -r user_input
    echo # Add newline after single character input

    case "${user_input}" in
      "q" | "Q")
        echo "Goodbye!"
        exit 0
        ;;
      "r" | "R")
        # Retry - continue to next iteration
        continue
        ;;
      *)
        echo "Invalid option '${user_input}'. Try again..."
        ;;
    esac
  fi
done
