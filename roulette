#!/usr/bin/env bash
# This script was generated by bashly 0.8.4 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  #!/usr/bin/env bash
  # shellcheck disable=SC2154  # GREEN, NC, ICON, YELLOW, RED, CYAN, DIM, version defined in initialize.sh
  echo -e "${GREEN}"
  print_logo
  echo "   r o u l e t t e"
  echo "   Version ${version}"
  echo ""
  echo -e "${NC}"

  DIRECTORY_PATH=""
  USER_PROVIDED_PATH=""

  if [[ -n "${args[directory]}" ]]; then
    USER_PROVIDED_PATH="${args[directory]}"
    USER_PROVIDED_PATH="${USER_PROVIDED_PATH/#\~/${HOME}}"
    if [[ ! -d "${USER_PROVIDED_PATH}" ]]; then
      echo -e "${RED}ERROR:${NC} Directory not found: ${USER_PROVIDED_PATH}"
      exit 1
    fi
    DIRECTORY_PATH="${USER_PROVIDED_PATH}"
    echo "Using provided directory: ${DIRECTORY_PATH}"
  fi

  detect_macos
  detect_wsl

  if [[ -z "${USER_PROVIDED_PATH}" ]]; then
    detect_media_directory
  fi

  check_and_install_mpv

  # Playlist file lives in the media directory
  PLAYLIST_FILE="${DIRECTORY_PATH}/.roulette_playlist"

  # Load or create playlist
  if [[ -f "${PLAYLIST_FILE}" ]] && [[ -z "${args['--reset']}" ]]; then
    load_playlist "${PLAYLIST_FILE}"
    echo "Loaded playlist: ${#PLAYLIST[@]} videos remaining"
  else
    if [[ -n "${args['--reset']}" ]]; then
      debug_log "Reset flag provided, rebuilding playlist"
    fi
    echo "Scanning directory: ${DIRECTORY_PATH}"
    PLAYLIST=()
    while IFS= read -r -d '' file; do
      PLAYLIST+=("${file}")
    done < <(list_videos)

    if [[ ${#PLAYLIST[@]} -eq 0 ]]; then
      echo "No video files found."
      exit 0
    fi

    save_playlist "${PLAYLIST_FILE}"
    echo "Found ${#PLAYLIST[@]} videos, saved playlist."
  fi

  open_random_video() {
    if [[ ${#PLAYLIST[@]} -eq 0 ]]; then
      echo "Playlist empty - all videos played!"
      echo "Use --reset to rebuild the playlist."
      return 1
    fi

    echo -e "${DIM}${#PLAYLIST[@]} videos remaining.${NC}"
    local random_index=$((RANDOM % ${#PLAYLIST[@]}))
    random_video="${PLAYLIST[${random_index}]}"
    debug_log "Selected index ${random_index} of ${#PLAYLIST[@]}: ${random_video}"

    # Verify file still exists
    if [[ ! -f "${random_video}" ]]; then
      debug_log "File not found, removing stale entry"
      echo "Video no longer exists, removing: ${random_video}"
      remove_from_playlist "${random_video}"
      save_playlist "${PLAYLIST_FILE}"
      return 2 # Signal to retry
    fi

    echo -e "${ICON} Playing: ${random_video}"

    local video_path
    video_path=$(convert_path_for_mpv "${random_video}")
    run_mpv "${video_path}"
  }

  while true; do
    open_random_video
    result=$?

    if [[ ${result} -eq 2 ]]; then
      # File not found, auto-retry
      continue
    elif [[ ${result} -eq 0 ]]; then
      # Track if video should be removed from playlist
      should_remove=false

      # Check if video was watched enough to auto-remove
      if is_video_watched_enough; then
        echo ""
        echo -e "${GREEN}Video watched (${LAST_PLAYBACK_PERCENT}%)${NC} - removed from playlist."
        should_remove=true
      else
        echo ""
        echo -e "${YELLOW}Video skipped (${LAST_PLAYBACK_PERCENT}%)${NC} - keeping in playlist."
      fi

      while true; do
        echo ""
        echo -e -n "[${CYAN}q${NC}]uit  [${RED}d${NC}]elete  [${DIM}i${NC}]nfo  [${DIM}r${NC}]eplay  [${GREEN}N${NC}]ext: "
        read -n 1 -r user_input
        echo
        debug_log "User input: '${user_input}'"

        case "${user_input}" in
          q | Q)
            debug_log "Action: quit"
            echo "Goodbye!"
            exit 0
            ;;
          r | R)
            debug_log "Action: replay"
            echo -e "${DIM}Replaying...${NC}"
            video_path=$(convert_path_for_mpv "${random_video}")
            run_mpv "${video_path}"
            continue
            ;;
          i | I)
            debug_log "Action: show info"
            mediainfo "${random_video}"
            while true; do
              echo -e -n "[${DIM}r${NC}]eplay  [${DIM}b${NC}]ack: "
              read -n 1 -r replay_input
              echo
              debug_log "Info submenu input: '${replay_input}'"
              case "${replay_input}" in
                r | R)
                  debug_log "Action: replay from info"
                  video_path=$(convert_path_for_mpv "${random_video}")
                  run_mpv "${video_path}"
                  ;;
                b | B | q | Q | $'\n' | "")
                  debug_log "Action: back to main menu"
                  break
                  ;;
                *)
                  echo -e "${YELLOW}Invalid option '${replay_input}'.${NC}"
                  ;;
              esac
            done
            continue
            ;;
          d | D)
            debug_log "Action: delete prompt"
            echo ""
            echo -e "${RED}WARNING:${NC} This will permanently delete the file:"
            echo -e "${DIM}${random_video}${NC}"
            echo ""
            echo -e -n "Delete? [${RED}y${NC}/Enter=yes, ${DIM}n${NC}=no, ${CYAN}q${NC}=quit]: "
            read -n 1 -r confirmation
            echo
            debug_log "Delete confirmation: '${confirmation}'"
            case "${confirmation}" in
              y | Y | $'\n' | "")
                debug_log "Action: confirmed delete"
                if rm "${random_video}" 2>/dev/null; then
                  echo -e "${GREEN}File deleted.${NC}"
                  should_remove=true
                else
                  echo -e "${RED}Failed to delete file.${NC} Check permissions."
                fi
                break
                ;;
              q | Q)
                debug_log "Action: quit from delete"
                echo "Goodbye!"
                exit 0
                ;;
              n | N | *)
                debug_log "Action: cancel delete"
                echo -e "${DIM}Cancelled.${NC}"
                continue
                ;;
            esac
            ;;
          n | N | ' ' | "")
            debug_log "Action: next video"
            break
            ;;
          *)
            echo -e "${YELLOW}Invalid option '${user_input}'.${NC}"
            continue
            ;;
        esac
      done

      # Remove from playlist if watched or deleted
      if [[ "${should_remove}" == true ]]; then
        remove_from_playlist "${random_video}"
        save_playlist "${PLAYLIST_FILE}"
      fi
    else
      echo ""
      echo -e -n "[${DIM}r${NC}]etry  [${CYAN}q${NC}]uit: "
      read -n 1 -r user_input
      echo
      case "${user_input}" in
        q | Q)
          echo "Goodbye!"
          exit 0
          ;;
        r | R)
          continue
          ;;
        *)
          echo -e "${YELLOW}Invalid option '${user_input}'.${NC}"
          ;;
      esac
    fi
  done

}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
roulette_usage() {
  if [[ -n $long_usage ]]; then
    printf "roulette - Play random video files from a directory\n"
    echo

  else
    printf "roulette - Play random video files from a directory\n"
    echo

  fi

  printf "Usage:\n"
  printf "  roulette [DIRECTORY] [options]\n"
  printf "  roulette --help | -h\n"
  printf "  roulette --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug, -d"
    printf "    Enable debug mode\n"
    echo

    # :flag.usage
    echo "  --reset"
    printf "    Empty playlist and rescan directory\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DIRECTORY"
    printf "    Path to search for video files\n"
    echo

    # :command.usage_environment_variables
    printf "Environment Variables:\n"

    # :environment_variable.usage
    echo "  ROULETTE_DEBUG"
    printf "    Enable debug mode\n"
    echo

    # :environment_variable.usage
    echo "  MPV_GEOMETRY"
    printf "    Set default window positioning (e.g., '+0+0')\n"
    echo

    # :environment_variable.usage
    echo "  MPV_VOLUME"
    printf "    Set default volume (0-100)\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if ((${#args[@]})); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
    --version | -v)
      version_command
      exit
      ;;

    --help | -h)
      long_usage=yes
      roulette_usage
      exit
      ;;

  esac

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --debug | -d)

        # :flag.case_no_arg
        args[--debug]=1
        shift
        ;;

      # :flag.case
      --reset)

        # :flag.case_no_arg
        args[--reset]=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args[directory]+x} ]]; then

          args[directory]=$1
          shift
        else
          printf "invalid argument: %s\n" "$key"
          exit 1
        fi

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="1.0.0"
  long_usage=''
  set -e

  # src/initialize.sh
  #!/usr/bin/env bash

  # Colors (used in root_command.sh)
  # shellcheck disable=SC2034
  GREEN='\033[1;32m'
  # shellcheck disable=SC2034
  YELLOW='\033[1;33m'
  # shellcheck disable=SC2034
  RED='\033[1;31m'
  # shellcheck disable=SC2034
  CYAN='\033[1;36m'
  # shellcheck disable=SC2034
  DIM='\033[2m'
  # shellcheck disable=SC2034
  NC='\033[0m'
  # shellcheck disable=SC2034
  ICON="${GREEN}(::X::)${NC}"

  # Debug logging function - prints verbose info when debug mode is enabled
  debug_log() {
    if [[ -n "${ROULETTE_DEBUG}" || -n "${args['--debug']:-}" ]]; then
      echo -e "${DIM}[DEBUG]${NC} $*" >&2
    fi
  }

  VIDEO_EXTENSIONS=(
    mp4 avi mkv mov wmv flv webm m4v mpg mpeg mp4
  )

  MPV_PATH="/usr/local/bin/mpv"
  MPV_PATH_ARM="/opt/homebrew/bin/mpv"
  IS_WSL=false
  IS_MACOS=false

  print_logo() {
    printf '%s\n' "    ----------------░░░░░░░-----------------"
    printf '%s\n' "    ---.--'-'''.---░░]▄▄▄▄▄░░--\`'''''-'-''''"
    printf '%s\n' "    ---------------░░░╣▒░╠▌░░----'''''''''''"
    printf '%s\n' "    ''---------;░░Q▄░▀╩▓╗▌╩╩Q▄▄░░----------'"
    printf '%s\n' "    ''''''.'.-;░╠▀░░░░░░▓░░░░░░▀▒µ---'''''''"
    printf '%s\n' "    ------'-»╔#░░▄╧--░░╚╠╩░░--@▄░╚▒░-'''''''"
    printf '%s\n' "     ''-'---╓╝░░╙╚≤░-\"\"░▓░░░░≤╛╚░∩╙╩░---'''"
    printf '%s\n' "         '!░║░░----└▒░;░▓░,µ▒░----░]▌░-"
    printf '%s\n' "         .-╣░░░░---░░│Φ░╙]▒│-----╓░\"]▌-'"
    printf '%s\n' "       ---░╣░\"╠▒╚▀▀▀▀▀▒░▀░╚▀▀▀▀▀▒╚▒-]▌░-'"
    printf '%s\n' "          .╝Q░,---.'\`,╗╩░φ░╚▄-''---░░░▌-"
    printf '%s\n' "          \`░║░----;@╚░':╣=-\"▒╦░----]▌└'"
    printf '%s\n' "           '-║▒-╙║░░---░▓░-\"\`░░φ▒-]▌└'"
    printf '%s\n' "            '└╙░░-╙---»≤░≥----╙;]ƒ╛░'"
    printf '%s\n' "               \`╙▀╦▄Q--└░░'.╓Qƒ▀▒⌐"
    printf '%s\n' "                 '└└└▀▀▀▀▀▀▀░└└''"
  }

  detect_wsl() {
    if grep -qEi "(Microsoft|WSL)" /proc/version &>/dev/null; then
      IS_WSL=true
      echo "WSL environment detected."
    fi
  }

  detect_macos() {
    if [[ "${OSTYPE}" == darwin* ]]; then
      IS_MACOS=true
      echo "macOS environment detected."
    fi
  }

  detect_media_directory() {
    local potential_paths=()

    if [[ "${IS_MACOS}" == true ]]; then
      potential_paths=(
        "/Volumes/media/archive/video"
      )
    elif [[ "${IS_WSL}" == true ]]; then
      potential_paths=(
        "/mnt/media/archive/video"
        "/media/archive/video"
        "/mnt/m/media/archive/video"
      )
    else
      potential_paths=(
        "/media/archive/video"
        "/mnt/media/archive/video"
      )
    fi

    for path in "${potential_paths[@]}"; do
      if [[ -d "${path}" ]]; then
        DIRECTORY_PATH="${path}"
        echo "Found media directory: ${DIRECTORY_PATH}"
        return 0
      fi
    done

    if [[ "${IS_MACOS}" == true ]]; then
      DIRECTORY_PATH="/Volumes/media/archive/video"
    elif [[ "${IS_WSL}" == true ]]; then
      DIRECTORY_PATH="/mnt/media/archive/video"
    else
      DIRECTORY_PATH="/media/archive/video"
    fi

    echo "WARNING: Media directory not found. Using default: ${DIRECTORY_PATH}"
    return 1
  }

  check_and_install_mpv() {
    # Prefer PATH mpv if available (helps testing and custom installs)
    if command -v mpv &>/dev/null; then
      MPV_PATH="$(command -v mpv)"
      echo "mpv found in PATH: ${MPV_PATH}"
      return 0
    fi
    if [[ "${IS_WSL}" == true ]]; then
      local win_mpv_paths=(
        "/mnt/c/Program Files/mpv/mpv.exe"
        "/mnt/c/Program Files (x86)/mpv/mpv.exe"
        "/mnt/c/Users/${USER}/AppData/Local/Programs/mpv.net/mpvnet.exe"
        "$(command -v mpv.exe 2>/dev/null)"
      )

      for path in "${win_mpv_paths[@]}"; do
        if [[ -f "${path}" ]]; then
          MPV_PATH="${path}"
          echo "Found Windows MPV at: ${MPV_PATH}"
          return 0
        fi
      done

      echo "ERROR: mpv.exe not found on Windows side."
      echo "Please install mpv for Windows from https://mpv.io/installation/"
      echo "Or ensure mpv.exe is in your Windows PATH."
      exit 1
    fi

    if [[ -f "${MPV_PATH}" ]] || [[ -f "${MPV_PATH_ARM}" ]]; then
      echo "mpv is already installed."
      if [[ -f "${MPV_PATH_ARM}" ]]; then
        MPV_PATH="${MPV_PATH_ARM}"
      fi
    else
      echo "mpv is not installed. Installing using Homebrew..."
      if ! command -v brew &>/dev/null; then
        echo "Homebrew is not installed. Please install Homebrew first:"
        echo "Visit https://brew.sh for installation instructions"
        exit 1
      fi
      if brew install mpv; then
        echo "mpv installed successfully."
        if [[ -f "${MPV_PATH_ARM}" ]]; then
          MPV_PATH="${MPV_PATH_ARM}"
        fi
      else
        echo "Failed to install mpv using Homebrew. Please install it manually."
        exit 1
      fi
    fi
  }

  convert_path_for_mpv() {
    local path="$1"
    if [[ "${IS_WSL}" == true ]]; then
      wslpath -w "${path}"
    else
      echo "${path}"
    fi
  }

  # Playback progress tracking
  LAST_PLAYBACK_PERCENT=0

  # Threshold for considering a video "watched" (percentage)
  WATCHED_THRESHOLD_PERCENT=10

  build_mpv_args() {
    local mpv_opts=()
    debug_log "Building mpv args: MPV_GEOMETRY='${MPV_GEOMETRY}' MPV_VOLUME='${MPV_VOLUME}'"
    if [[ -n "${MPV_GEOMETRY}" ]]; then
      mpv_opts+=("--geometry=${MPV_GEOMETRY}")
    fi
    if [[ -n "${MPV_VOLUME}" ]]; then
      mpv_opts+=("--volume=${MPV_VOLUME}")
    fi
    echo "${mpv_opts[@]}"
  }

  run_mpv() {
    local video_path="$1"
    local mpv_args
    mpv_args=$(build_mpv_args)

    debug_log "Executing: ${MPV_PATH} ${mpv_args} \"${video_path}\""

    # Reset playback tracking
    LAST_PLAYBACK_PERCENT=0

    # Run mpv and capture stderr to parse progress
    # mpv outputs status line like: AV: 00:00:02 / 00:39:45 (0%) A-V: -0.000
    local mpv_output
    # shellcheck disable=SC2086  # mpv_args intentionally unquoted - empty string should expand to nothing
    mpv_output=$("${MPV_PATH}" ${mpv_args} "${video_path}" 2>&1)
    local exit_code=$?

    # Parse the last AV line for progress percentage
    local percent
    percent=$(echo "${mpv_output}" | grep -o '([0-9]*%)' | tail -1 | tr -d '()%')
    if [[ -n "${percent}" ]]; then
      LAST_PLAYBACK_PERCENT="${percent}"
    fi

    debug_log "mpv exited with code ${exit_code}, playback: ${LAST_PLAYBACK_PERCENT}%"
    return ${exit_code}
  }

  is_video_watched_enough() {
    [[ ${LAST_PLAYBACK_PERCENT} -ge ${WATCHED_THRESHOLD_PERCENT} ]]
  }

  list_videos() {
    local find_args=(find "${DIRECTORY_PATH}" -type f '(')
    local i
    for ((i = 0; i < ${#VIDEO_EXTENSIONS[@]}; i++)); do
      local ext="${VIDEO_EXTENSIONS[${i}]}"
      find_args+=(-iname "*.${ext}")
      if ((i < ${#VIDEO_EXTENSIONS[@]} - 1)); then
        find_args+=(-o)
      fi
    done
    find_args+=(')')
    find_args+=(-print0)
    "${find_args[@]}"
  }

  # Playlist management functions
  PLAYLIST=()

  load_playlist() {
    local playlist_file="$1"
    debug_log "Loading playlist from: ${playlist_file}"
    PLAYLIST=()
    [[ ! -f "${playlist_file}" ]] && return 1
    while IFS= read -r line; do
      [[ -n "${line}" ]] && PLAYLIST+=("${line}")
    done <"${playlist_file}"
    debug_log "Loaded ${#PLAYLIST[@]} entries from playlist"
    return 0
  }

  save_playlist() {
    local playlist_file="$1"
    debug_log "Saving playlist to: ${playlist_file} (${#PLAYLIST[@]} entries)"
    mkdir -p "$(dirname "${playlist_file}")"
    printf '%s\n' "${PLAYLIST[@]}" >"${playlist_file}"
  }

  remove_from_playlist() {
    local video_to_remove="$1"
    debug_log "Removing from playlist: ${video_to_remove}"
    local new_playlist=()
    for v in "${PLAYLIST[@]}"; do
      [[ "${v}" != "${video_to_remove}" ]] && new_playlist+=("${v}")
    done
    PLAYLIST=("${new_playlist[@]}")
    debug_log "Playlist now has ${#PLAYLIST[@]} entries"
  }

}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
