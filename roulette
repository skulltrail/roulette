#!/usr/bin/env bash
# This script was generated by bashly 1.3.5 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "${version}"
}

# :command.usage
roulette_usage() {
  printf "roulette - Play random video files from a directory\n\n"

  printf "%s\n" "Usage:"
  printf "  roulette COMMAND\n"
  printf "  roulette [COMMAND] --help | -h\n"
  printf "  roulette --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Play random video files\n" "run"
  echo

  # :command.long_usage
  if [[ -n "${long_usage}" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "ROULETTE_DEBUG"
    printf "    Enable debug mode (any non-empty value)\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "MPV_GEOMETRY"
    printf "    Set mpv window geometry (e.g., '+0+0')\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "MPV_VOLUME"
    printf "    Set mpv volume (0-100)\n"
    echo

  fi
}

# :command.usage
roulette_run_usage() {
  printf "roulette run - Play random video files\n\n"

  printf "%s\n" "Usage:"
  printf "  roulette run [DIRECTORY] [OPTIONS]\n"
  printf "  roulette run --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "${long_usage}" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--debug, -d"
    printf "    Enable debug mode (show mpv command)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--save-played, -s"
    printf "    Save played files to omit in future runs\n"
    echo

    # :flag.usage
    printf "  %s\n" "--played-file, -p PATH"
    printf "    Path to the played files store (used with --save-played)\n"
    printf "    %s\n" "Default: ${HOME}/.roulette_played"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DIRECTORY"
    printf "    Path to search for video files\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ ${passthru} == true ]]; then
      input+=("${arg}")
    elif [[ ${arg} =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ ${arg} =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ ${arg} =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "${arg}" == "--" ]]; then
      passthru=true
      input+=("${arg}")
    else
      input+=("${arg}")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort) || true
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[${k}]} = ${args[${k}]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort) || true
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[${k}]} = ${deps[${k}]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort) || true
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$${k} = ${!k:-}"
    done
  fi
}

# :command.command_functions
# :command.function
roulette_run_command() {

  # src/run_command.sh
  echo -e "${GREEN}"
  print_logo
  echo "   r o u l e t t e"
  echo "   Version ${version}"
  echo ""
  echo -e "${NC}"

  DIRECTORY_PATH=""
  USER_PROVIDED_PATH=""

  if [[ -n "${args[directory]}" ]]; then
    USER_PROVIDED_PATH="${args[directory]}"
    USER_PROVIDED_PATH="${USER_PROVIDED_PATH/#\~/${HOME}}"
    if [[ ! -d "${USER_PROVIDED_PATH}" ]]; then
      echo "ERROR: Directory not found: ${USER_PROVIDED_PATH}"
      exit 1
    fi
    DIRECTORY_PATH="${USER_PROVIDED_PATH}"
    echo "Using provided directory: ${DIRECTORY_PATH}"
  fi

  detect_macos
  detect_wsl

  if [[ -z "${USER_PROVIDED_PATH}" ]]; then
    detect_media_directory
  fi

  check_and_install_mpv

  if [[ -n "${args['--save-played']}" ]]; then
    load_played_set
  fi

  open_random_video() {
    if [[ ! -d "${DIRECTORY_PATH}" ]]; then
      echo "Directory not found: ${DIRECTORY_PATH}"
      return 1
    fi

    videos=()
    while IFS= read -r -d '' file; do
      if [[ -n "${args['--save-played']}" ]] && [[ -n "${PLAYED_SET["${file}"]}" ]]; then
        continue
      fi
      videos+=("${file}")
    done < <(list_videos) || true

    if [[ ${#videos[@]} -eq 0 ]]; then
      echo "No unplayed video files found in: ${DIRECTORY_PATH}"
      return 1
    fi

    echo "Found ${#videos[@]} video files."
    local random_index=$((RANDOM % ${#videos[@]}))
    random_video="${videos[${random_index}]}"
    echo -e "${ICON} Playing: ${random_video}"

    local video_path
    video_path=$(
      set -e
      convert_path_for_mpv "${random_video}"
    )
    run_mpv "${video_path}"

    if [[ -n "${args['--save-played']}" ]]; then
      save_played "${random_video}"
    fi
  }

  while true; do
    if open_random_video; then
      while true; do
        echo ""
        echo -n "[q]uit, [d]elete, [i]nfo, [r]eplay, [N]ext: "
        read -n 1 -r user_input
        echo

        case "${user_input}" in
          q | Q)
            echo "Goodbye!"
            exit 0
            ;;
          r | R)
            echo "Replaying video: ${random_video}"
            video_path=$(
              set -e
              convert_path_for_mpv "${random_video}"
            )
            run_mpv "${video_path}"
            continue
            ;;
          i | I)
            mediainfo "${random_video}"
            while true; do
              echo -n "[r]replay, [b]ack: "
              read -n 1 -r replay_input
              echo
              case "${replay_input}" in
                r | R)
                  video_path=$(
                    set -e
                    convert_path_for_mpv "${random_video}"
                  )
                  run_mpv "${video_path}"
                  ;;
                b | B | q | Q | $'\n' | "")
                  break
                  ;;
                *)
                  echo "Invalid option '${replay_input}'. Try again..."
                  ;;
              esac
            done
            continue
            ;;
          d | D)
            echo ""
            echo "WARNING: This will permanently delete the file:"
            echo "${random_video}"
            echo ""
            echo -n "Delete this file? [y/Enter=yes, n=no, q=quit]: "
            read -n 1 -r confirmation
            echo
            case "${confirmation}" in
              y | Y | $'\n' | "")
                if rm "${random_video}" 2>/dev/null; then
                  echo "File deleted successfully."
                else
                  echo "Failed to delete file. Check permissions."
                fi
                break
                ;;
              q | Q)
                echo "Goodbye!"
                exit 0
                ;;
              n | N | *)
                echo "File deletion cancelled."
                continue
                ;;
            esac
            ;;
          n | N | ' ' | "")
            break
            ;;
          *)
            echo "Invalid option '${user_input}'. Try again..."
            continue
            ;;
        esac
      done
    else
      echo ""
      echo -n "[r]etry, [q]uit: "
      read -n 1 -r user_input
      echo
      case "${user_input}" in
        q | Q)
          echo "Goodbye!"
          exit 0
          ;;
        r | R)
          continue
          ;;
        *)
          echo "Invalid option '${user_input}'. Try again..."
          ;;
      esac
    fi
  done

}

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "${key}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        roulette_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("ROULETTE_DEBUG")
  env_var_names+=("MPV_GEOMETRY")
  env_var_names+=("MPV_VOLUME")

  # :command.command_filter
  action=${1:-}

  case ${action} in
    -*) ;;

    run)
      action="run"
      shift
      roulette_run_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      roulette_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "${action}" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "${key}" in

      -?*)
        printf "invalid option: %s\n" "${key}" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "${key}" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
roulette_run_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "${key}" in
      --help | -h)
        long_usage=yes
        roulette_run_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="run"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "${key}" in
      # :flag.case
      --debug | -d)

        # :flag.case_no_arg
        args['--debug']=1
        shift
        ;;

      # :flag.case
      --save-played | -s)

        # :flag.case_no_arg
        args['--save-played']=1
        shift
        ;;

      # :flag.case
      --played-file | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--played-file']="$2"
          shift
          shift
        else
          printf "%s\n" "--played-file requires an argument: --played-file, -p PATH" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "${key}" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['directory']+x} ]]; then
          args['directory']=$1
          shift
        else
          printf "invalid argument: %s\n" "${key}" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--played-file']:-} ]] || args['--played-file']="${HOME}/.roulette_played"

}

# :command.initialize
initialize() {
  declare -g version="1.0.0"
  set -e

  # src/initialize.sh
  #!/usr/bin/env bash

  GREEN='\033[1;32m'
  NC='\033[0m'
  ICON="${GREEN}(::X::)${NC}"

  VIDEO_EXTENSIONS=(
    mp4 avi mkv mov wmv flv webm m4v mpg mpeg mp4
  )

  MPV_PATH="/usr/local/bin/mpv"
  MPV_PATH_ARM="/opt/homebrew/bin/mpv"
  IS_WSL=false
  IS_MACOS=false

  print_logo() {
    cat <<'EOF'
    ----------------░░░░░░░-----------------
    ---.--'-'''.---░░]▄▄▄▄▄░░--`'''''-'-''''
    ---------------░░░╣▒░╠▌░░----'''''''''''
    ''---------;░░Q▄░▀╩▓╗▌╩╩Q▄▄░░----------'
    ''''''.'.-;░╠▀░░░░░░▓░░░░░░▀▒µ---'''''''
    ------'-»╔#░░▄╧--░░╚╠╩░░--@▄░╚▒░-'''''''
     ''-'---╓╝░░╙╚≤░-""░▓░░░░≤╛╚░∩╙╩░---'''
         '!░║░░----└▒░;░▓░,µ▒░----░]▌░-
         .-╣░░░░---░░│Φ░╙]▒│-----╓░"]▌-'
       ---░╣░"╠▒╚▀▀▀▀▀▒░▀░╚▀▀▀▀▀▒╚▒-]▌░-'
          .╝Q░,---.`,╗╩░φ░╚▄-''---░░░▌-
          `░║░----;@╚░':╣=-"▒╦░----]▌└'
           '-║▒-╙║░░---░▓░-"`░░φ▒-]▌└'
            '└╙░░-╙---»≤░≥----╙;]ƒ╛░'
               `╙▀╦▄Q--└░░'.╓Qƒ▀▒⌐
                 '└└└▀▀▀▀▀▀▀░└└''
EOF
  }

  detect_wsl() {
    if grep -qEi "(Microsoft|WSL)" /proc/version &>/dev/null; then
      IS_WSL=true
      echo "WSL environment detected."
    fi
  }

  detect_macos() {
    if [[ "${OSTYPE}" == darwin* ]]; then
      IS_MACOS=true
      echo "macOS environment detected."
    fi
  }

  detect_media_directory() {
    local potential_paths=()

    if [[ "${IS_MACOS}" == true ]]; then
      potential_paths=(
        "/Volumes/media/archive/video"
      )
    elif [[ "${IS_WSL}" == true ]]; then
      potential_paths=(
        "/mnt/media/archive/video"
        "/media/archive/video"
        "/mnt/m/media/archive/video"
      )
    else
      potential_paths=(
        "/media/archive/video"
        "/mnt/media/archive/video"
      )
    fi

    for path in "${potential_paths[@]}"; do
      if [[ -d "${path}" ]]; then
        DIRECTORY_PATH="${path}"
        echo "Found media directory: ${DIRECTORY_PATH}"
        return 0
      fi
    done

    if [[ "${IS_MACOS}" == true ]]; then
      DIRECTORY_PATH="/Volumes/media/archive/video"
    elif [[ "${IS_WSL}" == true ]]; then
      DIRECTORY_PATH="/mnt/media/archive/video"
    else
      DIRECTORY_PATH="/media/archive/video"
    fi

    echo "WARNING: Media directory not found. Using default: ${DIRECTORY_PATH}"
    return 1
  }

  check_and_install_mpv() {
    # Prefer PATH mpv if available (helps testing and custom installs)
    if command -v mpv &>/dev/null; then
      MPV_PATH="$(command -v mpv)"
      echo "mpv found in PATH: ${MPV_PATH}"
      return 0
    fi
    if [[ "${IS_WSL}" == true ]]; then
      local win_mpv_paths=(
        "/mnt/c/Program Files/mpv/mpv.exe"
        "/mnt/c/Program Files (x86)/mpv/mpv.exe"
        "/mnt/c/Users/${USER}/AppData/Local/Programs/mpv.net/mpvnet.exe"
        "$(command -v mpv.exe 2>/dev/null)"
      )

      for path in "${win_mpv_paths[@]}"; do
        if [[ -f "${path}" ]]; then
          MPV_PATH="${path}"
          echo "Found Windows MPV at: ${MPV_PATH}"
          return 0
        fi
      done

      echo "ERROR: mpv.exe not found on Windows side."
      echo "Please install mpv for Windows from https://mpv.io/installation/"
      echo "Or ensure mpv.exe is in your Windows PATH."
      exit 1
    fi

    if [[ -f "${MPV_PATH}" ]] || [[ -f "${MPV_PATH_ARM}" ]]; then
      echo "mpv is already installed."
      if [[ -f "${MPV_PATH_ARM}" ]]; then
        MPV_PATH="${MPV_PATH_ARM}"
      fi
    else
      echo "mpv is not installed. Installing using Homebrew..."
      if ! command -v brew &>/dev/null; then
        echo "Homebrew is not installed. Please install Homebrew first:"
        echo "Visit https://brew.sh for installation instructions"
        exit 1
      fi
      if brew install mpv; then
        echo "mpv installed successfully."
        if [[ -f "${MPV_PATH_ARM}" ]]; then
          MPV_PATH="${MPV_PATH_ARM}"
        fi
      else
        echo "Failed to install mpv using Homebrew. Please install it manually."
        exit 1
      fi
    fi
  }

  convert_path_for_mpv() {
    local path="$1"
    if [[ "${IS_WSL}" == true ]]; then
      wslpath -w "${path}"
    else
      echo "${path}"
    fi
  }

  build_mpv_args() {
    local mpv_args_arr=()
    if [[ -n "${MPV_GEOMETRY}" ]]; then
      mpv_args_arr+=("--geometry=${MPV_GEOMETRY}")
    fi
    if [[ -n "${MPV_VOLUME}" ]]; then
      mpv_args_arr+=("--volume=${MPV_VOLUME}")
    fi
    echo "${mpv_args_arr[@]}"
  }

  run_mpv() {
    local video_path="$1"
    local mpv_args
    mpv_args=$(
      set -e
      build_mpv_args
    )

    if [[ -n "${ROULETTE_DEBUG}" || -n "${args['--debug']}" ]]; then
      echo -e "${GREEN}[DEBUG]${NC} ${MPV_PATH} ${mpv_args} \"${video_path}\""
    fi
    "${MPV_PATH}" "${mpv_args}" "${video_path}"
  }

  build_find_command() {
    local find_cmd="find \"${DIRECTORY_PATH}\" -type f \\\( "
    local first=true
    for ext in "${VIDEO_EXTENSIONS[@]}"; do
      if [[ "${first}" == true ]]; then
        find_cmd+="-iname \"*.${ext}\""
        first=false
      else
        find_cmd+=" -o -iname \"*.${ext}\""
      fi
    done
    find_cmd+=" \\\)"
    echo "${find_cmd}"
  }

  list_videos() {
    local find_args=(find "${DIRECTORY_PATH}" -type f '(')
    local i
    for ((i = 0; i < ${#VIDEO_EXTENSIONS[@]}; i++)); do
      local ext="${VIDEO_EXTENSIONS[${i}]}"
      find_args+=(-iname "*.${ext}")
      if ((i < ${#VIDEO_EXTENSIONS[@]} - 1)); then
        find_args+=(-o)
      fi
    done
    find_args+=(')')
    find_args+=(-print0)
    "${find_args[@]}"
  }

  load_played_set() {
    PLAYED_SET_FILE="${args['--played-file']}"
    if [[ -z "${PLAYED_SET_FILE}" ]]; then
      PLAYED_SET_FILE="${HOME}/.roulette_played"
    fi
    declare -gA PLAYED_SET
    PLAYED_SET=()
    if [[ -f "${PLAYED_SET_FILE}" ]]; then
      while IFS= read -r line; do
        [[ -n "${line}" ]] && PLAYED_SET["${line}"]=1
      done <"${PLAYED_SET_FILE}"
    fi
  }

  save_played() {
    local path="$1"
    [[ -z "${path}" ]] && return 0
    PLAYED_SET_FILE="${args['--played-file']}"
    if [[ -z "${PLAYED_SET_FILE}" ]]; then
      PLAYED_SET_FILE="${HOME}/.roulette_played"
    fi
    mkdir -p "$(dirname "${PLAYED_SET_FILE}")"
    printf "%s\n" "${path}" >>"${PLAYED_SET_FILE}"
  }

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "${action}" in
    "run") roulette_run_command ;;
    *)
      echo "Unknown action: ${action}" >&2
      exit 1
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
