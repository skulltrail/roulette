name: Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install BATS (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y bats

      - name: Install BATS (macOS)
        if: runner.os == 'macOS'
        run: brew install bats-core

      - name: Install shellcheck and shfmt
        run: make setup

      - name: Run linting
        run: make lint

      - name: Run format check
        run: make format-check

      - name: Run legacy tests
        run: make test

      - name: Run BATS tests
        run: make test-bats

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.os }}
          path: |
            tests/*.log
            tests/*.txt
          if-no-files-found: ignore

  coverage:
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install BATS
        run: sudo apt-get update && sudo apt-get install -y bats

      - name: Generate test report
        run: |
          bats tests/test_roulette.bats --formatter tap > test-report.tap
          echo "## Test Results" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          bats tests/test_roulette.bats --count >> $GITHUB_STEP_SUMMARY
          echo " tests completed" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  version-bump:
    runs-on: ubuntu-latest
    needs: [test, coverage]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Determine version bump
        id: version
        run: |
          # Read current version
          CURRENT_VERSION=$(cat VERSION)
          echo "Current version: $CURRENT_VERSION"

          # Get commit messages since last version tag
          if git describe --tags --abbrev=0 2>/dev/null; then
            LAST_TAG=$(git describe --tags --abbrev=0)
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s")
          else
            COMMITS=$(git log --pretty=format:"%s")
          fi

          echo "Analyzing commits:"
          echo "$COMMITS"

          # Determine bump type from conventional commits
          BUMP_TYPE="patch"

          if echo "$COMMITS" | grep -qE "^(feat|feature)(\(.+\))?!:|^[^:]+!:"; then
            BUMP_TYPE="major"
          elif echo "$COMMITS" | grep -qE "^BREAKING CHANGE:|^[^:]*!:"; then
            BUMP_TYPE="major"
          elif echo "$COMMITS" | grep -qE "^(feat|feature)(\(.+\))?:"; then
            BUMP_TYPE="minor"
          elif echo "$COMMITS" | grep -qE "^(fix|bugfix|perf)(\(.+\))?:"; then
            BUMP_TYPE="patch"
          else
            echo "No conventional commits found, skipping version bump"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Bump type: $BUMP_TYPE"

          # Parse version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          # Bump version
          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "New version: $NEW_VERSION"

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT

      - name: Update version files
        if: steps.version.outputs.skip != 'true'
        run: |
          NEW_VERSION=${{ steps.version.outputs.new_version }}

          # Update VERSION file
          echo "$NEW_VERSION" > VERSION

          # Update bashly.yml
          sed -i "s/^version: .*/version: \"$NEW_VERSION\"/" src/bashly.yml

          # Update roulette script
          sed -i "s/declare -g version=.*/declare -g version=\"$NEW_VERSION\"/" roulette

          echo "Updated version to $NEW_VERSION in all files"

      - name: Commit and tag version
        if: steps.version.outputs.skip != 'true'
        run: |
          NEW_VERSION=${{ steps.version.outputs.new_version }}

          git add VERSION src/bashly.yml roulette
          git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
          git tag -a "v$NEW_VERSION" -m "Release version $NEW_VERSION"
          git push origin main
          git push origin "v$NEW_VERSION"

      - name: Create GitHub Release
        if: steps.version.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const newVersion = '${{ steps.version.outputs.new_version }}';

            // Get commits since last release
            const commits = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: 'HEAD~10',
              head: 'HEAD'
            });

            // Group commits by type
            const features = [];
            const fixes = [];
            const other = [];

            for (const commit of commits.data.commits) {
              const msg = commit.commit.message.split('\n')[0];
              if (msg.match(/^feat(\(.+\))?:/)) {
                features.push(`- ${msg.replace(/^feat(\(.+\))?:\s*/, '')}`);
              } else if (msg.match(/^fix(\(.+\))?:/)) {
                fixes.push(`- ${msg.replace(/^fix(\(.+\))?:\s*/, '')}`);
              } else if (!msg.match(/^chore(\(.+\))?:/)) {
                other.push(`- ${msg}`);
              }
            }

            // Build release notes
            let body = `## Release v${newVersion}\n\n`;

            if (features.length > 0) {
              body += '### ‚ú® Features\n' + features.join('\n') + '\n\n';
            }
            if (fixes.length > 0) {
              body += '### üêõ Bug Fixes\n' + fixes.join('\n') + '\n\n';
            }
            if (other.length > 0) {
              body += '### üìù Other Changes\n' + other.join('\n') + '\n\n';
            }

            // Create release
            await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${newVersion}`,
              name: `v${newVersion}`,
              body: body,
              draft: false,
              prerelease: false
            });
